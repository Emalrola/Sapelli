/**
 * Sapelli data collection platform: http://sapelli.org
 * 
 * Copyright 2012-2014 University College London - ExCiteS group
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and 
 * limitations under the License.
 */

package uk.ac.ucl.excites.sapelli.storage.eximport.xml;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

import org.xml.sax.SAXException;

import uk.ac.ucl.excites.sapelli.shared.util.ExceptionHelpers;
import uk.ac.ucl.excites.sapelli.shared.util.xml.DocumentParser;
import uk.ac.ucl.excites.sapelli.shared.util.xml.XMLAttributes;
import uk.ac.ucl.excites.sapelli.storage.StorageClient;
import uk.ac.ucl.excites.sapelli.storage.eximport.Importer;
import uk.ac.ucl.excites.sapelli.storage.eximport.helpers.ImportColumnValueParser;
import uk.ac.ucl.excites.sapelli.storage.eximport.xml.XMLRecordsExporter.CompositeMode;
import uk.ac.ucl.excites.sapelli.storage.model.Column;
import uk.ac.ucl.excites.sapelli.storage.model.ColumnSet;
import uk.ac.ucl.excites.sapelli.storage.model.Record;
import uk.ac.ucl.excites.sapelli.storage.model.Schema;
import uk.ac.ucl.excites.sapelli.storage.model.ValueSet;
import uk.ac.ucl.excites.sapelli.storage.model.ValueSetColumn;
import uk.ac.ucl.excites.sapelli.storage.model.VirtualColumn;
import uk.ac.ucl.excites.sapelli.storage.types.Location;
import uk.ac.ucl.excites.sapelli.storage.types.LocationColumn;
import uk.ac.ucl.excites.sapelli.storage.util.ColumnPointer;
import uk.ac.ucl.excites.sapelli.storage.util.UnknownModelException;

/**
 * XML {@link DocumentParser} that imports {@link Record}s from XML files generated by the current and previous versions of {@link XMLRecordsExporter}.
 * 
 * <p>Supported formats:<br/>
 * 	- v1.x exports, with both v1.x versions of the {@link Location} serialisation format (see {@link Location#parseV1X(String)}).<br/>
 *  - All 3 {@link CompositeMode}s supported by {@link XMLRecordsExporter}: {@link CompositeMode#String}, {@link CompositeMode#Flat} & {@link CompositeMode#Nested}<br/>
 * </p>
 * <p>Note about the tagColumnDepths stack:<br/>
 * 	We use tagColumnDepths stack to remember the "depth levels" represented by each opened column tag.
 * 	For example:<br/>
 * 		- {@code <StartTime>} --> 1 level deep (= top level column)<br/>
 * 		- {@code <Location>} --> 1 level deep (= top level column)<br/>
 * 		- {@code <Location.Latitude>} --> 2 levels deep<br/>
 * 	This information tells many levels to backtrack (i.e. "shortening" the {@code currentCP}) when the tag
 * 	is closed (see {@link #endElement(String,String,String)}).<br/>
 * 	When the XML is in {@link CompositeMode#Nested}, this will only be "known" when we hit the 2nd
 * 	nesting level (e.g. {@code <Latitude>} occurring within {@code <Location>}).<br/>
 * 	In these cases we must have a way to know that no CDATA should be parsed at the level of the
 * 	outer tag. There are 2 bits of CDATA to ignore: the leading and the trailing whitespace, e.g.:<br/>
 * 		- leading white space:	{@code <Location>\n\t\t\t<Latitude>1.6279193200170994</Latitude>}<br/>
 * 		- trailing white space:	{@code </Provider>\n\t\t</Location>}<br/>
 * 	The first kind is easily ignored by postponing the parsing of column value Strings until the
 * 	containing tag is closed (see {@link #characters(char[],int,int)} and {@link #endElement(String,String,String)})
 * 	and by wiping the {@code currentStringBldr} upon the opening of each new column tag.<br/>
 * 	The second kind is a bit more tricky. To know to ignore the trailing whitespace we make the column
 * 	depth of the outer tag negative, which is then checked in {@link #endElement(String,String,String)}
 * 	in order to skip parsing String contents when closing the outer tag.
 * 
 * @author mstevens
 */
public class XMLRecordsImporter extends DocumentParser implements Importer
{

	protected final StorageClient client;
	protected Record currentRecord;
	protected ColumnPointer<?> currentCP;
	protected Stack<Integer> tagColumnDepths;
	protected Stack<String> ignoreTags;
	protected StringBuilder currentStringBldr;
	protected boolean v1xExport;
	protected ImportColumnValueParser valueParser;
	protected List<Record> records;

	public XMLRecordsImporter(StorageClient client)
	{
		super();
		this.client = client;
	}

	/* (non-Javadoc)
	 * @see uk.ac.ucl.excites.sapelli.storage.eximport.xml.Importer#importFrom(java.io.File)
	 */
	@Override
	public List<Record> importFrom(File xmlFile) throws UnknownModelException, IndexOutOfBoundsException, Exception
	{
		records = new ArrayList<Record>();
		currentRecord = null;
		ignoreTags = new Stack<String>();
		currentStringBldr = new StringBuilder();
		currentCP = null;
		tagColumnDepths = new Stack<Integer>();
		valueParser = new ImportColumnValueParser();
		parse(open(xmlFile));
		return records;
	}

	@Override
	public void startDocument() throws SAXException
	{
		// does nothing (for now)
	}

	@SuppressWarnings("unchecked")
	@Override
	public void parseStartElement(String uri, String localName, String qName, XMLAttributes attributes) throws UnknownModelException, IndexOutOfBoundsException, SAXException
	{
		// <RecordsExport>
		if(qName.equals(XMLRecordsExporter.TAG_RECORDS_EXPORT) && ignoreTags.isEmpty())
		{
			// does nothing (but keep this if-block!)
		}
		// <Record>
		else if(qName.equals(Record.TAG_RECORD) && ignoreTags.isEmpty())
		{
			if(currentRecord != null)
				throw new SAXException("Records cannot be nested!");
			Schema schema = null;
			try
			{
				if(attributes.contains(Schema.V1X_ATTRIBUTE_SCHEMA_ID))
				{	//This file contains records exported by Sapelli v1.x
					int schemaID = attributes.getRequiredInteger(Record.TAG_RECORD, Schema.V1X_ATTRIBUTE_SCHEMA_ID, "because this is a v1.x record");
					int schemaVersion = attributes.getInteger(Schema.V1X_ATTRIBUTE_SCHEMA_VERSION, Schema.V1X_DEFAULT_SCHEMA_VERSION);
					schema = client.getSchemaV1(schemaID, schemaVersion);
					v1xExport = true;
				}
				else
				{
					long modelID = attributes.getRequiredLong(Record.TAG_RECORD, Schema.ATTRIBUTE_MODEL_ID);
					int modelSchemaNo = attributes.getRequiredInteger(Record.TAG_RECORD, Schema.ATTRIBUTE_MODEL_SCHEMA_NUMBER);
					String schemaName = attributes.getString(Schema.ATTRIBUTE_SCHEMA_NAME, null, false, false);
					schema = client.getSchema(modelID, modelSchemaNo, schemaName);
					v1xExport = false;
				}
			}
			catch(IllegalArgumentException iae)
			{
				new SAXException("This is not a valid Sapelli XML record export (missing model/schema identification attribute(s))");
			}
			if(schema != null)
				currentRecord = schema.createRecord();
			currentCP = null;
		}
		// Columns:
		else if(currentRecord != null && ignoreTags.isEmpty())
		{
			// Wipe any currentString if there is one:
			currentStringBldr.setLength(0);
			// Find the column:
			try
			{
				if(currentCP != null)
					currentCP = ColumnPointer.ExtendByName((ColumnPointer<ValueSetColumn<?, ?>>) currentCP, qName, false, false);
				else
					currentCP = ColumnPointer.ByName(currentRecord.getSchema(), qName, false, false);
				// Note: the ColumnPointer#By() and ColumnPointer#ExtendByName() methods support splitting at ValueSetColumn.QUALIFIED_NAME_SEPARATOR
			}
			catch(IllegalArgumentException iae)
			{
				ColumnSet currentCS = (currentCP != null) ? ((ColumnPointer<ValueSetColumn<?, ?>>) currentCP).getColumn().getColumnSet() : currentRecord.getSchema();
				addWarning("Skipping column " + qName + " because it does not exist in " + currentCS.toString());
				ignoreTags.push(qName);
				return;
			}
			
			// Skip virtual columns:
			if(currentCP.getColumn() instanceof VirtualColumn)
			{
				currentCP = currentCP.getParentPointer();
				ignoreTags.push(qName);
				return;
			}
			
			// Manipulate the tagColumnDepths stack (see class javadoc):
			if(!tagColumnDepths.isEmpty() && tagColumnDepths.peek() > 0)
				tagColumnDepths.push(tagColumnDepths.pop() * -1); // we reached the inner level of nested subcolumns, make preceeding columnDepth negative so we know it was nested upon closing
			tagColumnDepths.push(currentCP.getPathDepth() - (tagColumnDepths.isEmpty() ? 0 : Math.abs(tagColumnDepths.peek())));
			
			// Create (sub)ValueSet/Record (if needed):
			currentCP.createValueSet(currentRecord);
		}
		// <?>
		else
		{
			addWarning("Ignored unrecognised or invalidly placed element \"" + qName + "\", ignored.");
			ignoreTags.push(qName);
		}
	}

	@Override
	public void characters(char[] ch, int start, int length) throws SAXException
	{
		currentStringBldr.append(new String(ch, start, length));
		/* Note: 
			we postpone the parsing of column value Strings until the tag that contains it is closed.
			This allows us to ignore the *leading* whitespace between nesting levels. See class javadoc. */
	}
	
	/**
	 * Called with the currentString when a Column tag is closed
	 */
	private void parseColumnValue()
	{
		if(currentCP == null)
			return;
		
		// Get (sub)ValueSet/Record:
		ValueSet<?> valueSet = currentCP.getValueSet(currentRecord, false /*don't create*/); // (sub)record recreation happens in parseStartElement (and should stay there!)
		
		// Get the pointed-at column:
		Column<?> column = currentCP.getColumn();
		
		// The valueString:
		String valueString = currentStringBldr.toString();
		
		// Parse & store value:
		try
		{
			if(v1xExport && column instanceof LocationColumn)
				// Backwards compatibility with old location formats:
				((LocationColumn) column).storeValue(valueSet, Location.parseV1X(valueString));
			else
				// Use the value parser:
				valueParser.parseAndStoreValue(column, valueString, valueSet);
		}
		catch(Exception e)
		{
			addWarning(e.getClass().getSimpleName() + " upon parsing value (" + currentStringBldr + ") for " + column.toString() + " \"" + column.getName() + "\" [Info: " + ExceptionHelpers.getMessageAndCause(e) + ".");
		}
	}
	
	@Override
	public void endElement(String uri, String localName, String qName) throws SAXException
	{
		// <RecordsExport>
		if(qName.equals(XMLRecordsExporter.TAG_RECORDS_EXPORT) && ignoreTags.isEmpty())
		{
			// does nothing (but keep this if-block!!!)
		}
		// </Record>
		else if(qName.equals(Record.TAG_RECORD) && ignoreTags.isEmpty())
		{
			if(!currentRecord.isFilled(true)) // recursive "filledness" check
				addWarning("Imported record is incomplete: " + currentRecord.toString(false));
			records.add(currentRecord);
			currentRecord = null;
		}
		// Columns:
		else if(currentCP != null && ignoreTags.isEmpty()) // currentCP not being null also implies there is a currentRecord and tagColumnDepths is not empty
		{
			if(tagColumnDepths.peek() > 0) // skip parsing for negative column depths (this means we are closing an outer tag of a subcolumn nesting), see class javadoc.
				parseColumnValue(); // Will parse currentString (= CDATA contents of the tag being closed) if it is not null
			
			// Backtrack currentCP (as many levels as represented by the tag being closed):
			for(int l = Math.abs(tagColumnDepths.pop()); l > 0; l--)
				if(currentCP != null) // (just in case)
					currentCP = currentCP.getParentPointer();
		}
		// <?>
		else if(!ignoreTags.isEmpty())
		{
			ignoreTags.pop();
		}
	}

	@Override
	public void endDocument() throws SAXException
	{
		// does nothing for now
	}

}
