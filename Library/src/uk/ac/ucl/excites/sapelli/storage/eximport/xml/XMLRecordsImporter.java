/**
 * Sapelli data collection platform: http://sapelli.org
 * 
 * Copyright 2012-2014 University College London - ExCiteS group
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and 
 * limitations under the License.
 */

package uk.ac.ucl.excites.sapelli.storage.eximport.xml;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;

import org.xml.sax.SAXException;

import uk.ac.ucl.excites.sapelli.shared.util.CollectionUtils;
import uk.ac.ucl.excites.sapelli.shared.util.ExceptionHelpers;
import uk.ac.ucl.excites.sapelli.shared.util.xml.DocumentParser;
import uk.ac.ucl.excites.sapelli.shared.util.xml.XMLAttributes;
import uk.ac.ucl.excites.sapelli.storage.StorageClient;
import uk.ac.ucl.excites.sapelli.storage.eximport.Exporter;
import uk.ac.ucl.excites.sapelli.storage.eximport.Importer;
import uk.ac.ucl.excites.sapelli.storage.eximport.SimpleExporter;
import uk.ac.ucl.excites.sapelli.storage.eximport.helpers.ImportHelper;
import uk.ac.ucl.excites.sapelli.storage.eximport.xml.XMLRecordsExporter.CompositeMode;
import uk.ac.ucl.excites.sapelli.storage.model.Column;
import uk.ac.ucl.excites.sapelli.storage.model.ColumnSet;
import uk.ac.ucl.excites.sapelli.storage.model.Model;
import uk.ac.ucl.excites.sapelli.storage.model.Record;
import uk.ac.ucl.excites.sapelli.storage.model.Schema;
import uk.ac.ucl.excites.sapelli.storage.model.ValueSet;
import uk.ac.ucl.excites.sapelli.storage.model.ValueSetColumn;
import uk.ac.ucl.excites.sapelli.storage.model.VirtualColumn;
import uk.ac.ucl.excites.sapelli.storage.types.Location;
import uk.ac.ucl.excites.sapelli.storage.types.LocationColumn;
import uk.ac.ucl.excites.sapelli.storage.types.Orientation;
import uk.ac.ucl.excites.sapelli.storage.types.OrientationColumn;
import uk.ac.ucl.excites.sapelli.storage.types.TimeStamp;
import uk.ac.ucl.excites.sapelli.storage.util.ColumnPointer;
import uk.ac.ucl.excites.sapelli.storage.util.UnknownModelException;

/**
 * XML {@link DocumentParser} that imports {@link Record}s from XML files generated by the current and previous versions of {@link XMLRecordsExporter}.
 * 
 * <p>Supported formats:<br/>
 * 	- v1.x exports, with support for both v1.x versions of the {@link Location} serialisation format (see {@link Location#parseV1X(String)}), and the v1.x {@link Orientation} serialisation format (see {@link Orientation#parseV1X(String)}.<br/>
 *  - All 3 {@link CompositeMode}s supported by {@link XMLRecordsExporter}: {@link CompositeMode#String}, {@link CompositeMode#Flat} & {@link CompositeMode#Nested}<br/>
 * </p>
 * <p>Note about the tagColumnDepths stack:<br/>
 * 	We use tagColumnDepths stack to remember the "depth levels" represented by each opened column tag.
 * 	For example:<br/>
 * 		- {@code <StartTime>} --> 1 level deep (= top level column)<br/>
 * 		- {@code <Location>} --> 1 level deep (= top level column)<br/>
 * 		- {@code <Location.Latitude>} --> 2 levels deep<br/>
 * 	This information tells many levels to backtrack (i.e. "shortening" the {@code currentCP}) when the tag
 * 	is closed (see {@link #endElement(String,String,String)}).<br/>
 * 	When the XML is in {@link CompositeMode#Nested}, this will only be "known" when we hit the 2nd
 * 	nesting level (e.g. {@code <Latitude>} occurring within {@code <Location>}).<br/>
 * 	In these cases we must have a way to know that no CDATA should be parsed at the level of the
 * 	outer tag. There are 2 bits of CDATA to ignore: the leading and the trailing whitespace, e.g.:<br/>
 * 		- leading white space:	{@code <Location>\n\t\t\t<Latitude>1.6279193200170994</Latitude>}<br/>
 * 		- trailing white space:	{@code </Provider>\n\t\t</Location>}<br/>
 * 	The first kind is easily ignored by postponing the parsing of column value Strings until the
 * 	containing tag is closed (see {@link #characters(char[],int,int)} and {@link #endElement(String,String,String)})
 * 	and by wiping the {@code currentStringBldr} upon the opening of each new column tag.<br/>
 * 	The second kind is a bit more tricky. To know to ignore the trailing whitespace we make the column
 * 	depth of the outer tag negative, which is then checked in {@link #endElement(String,String,String)}
 * 	in order to skip parsing String contents when closing the outer tag.
 * </p>
 * <p>The column depth of ValueSetColumns which are marked as empty (using the {@link XMLRecordsExporter#ATTRIBUTE_VALUESETCOLUMN_EMPTY}
 * introduced in Sapelli v2.0-beta-17) is also made negative.
 * </p>
 * <p>In both cases the result is that whatever CDATA the ValueSetColumn tag contains will be ignored. Instead the empty String ("") is
 * passed to {@link XMLImportHelper#parseAndStoreValue(Column, String, ValueSet)} which ensures an empty sub-ValueSet is inserted.
 * This allows us to maintain the difference between {@code null} and empty (i.e. with all {@code null} values) sub-ValueSets. 
 * 
 * @author mstevens
 */
public class XMLRecordsImporter extends DocumentParser implements Importer
{
	
	protected final StorageClient client;
	protected final Map<Long, Model> modelCache;
	
	protected final Stack<Integer> tagColumnDepths;
	protected final Stack<String> ignoreTags;
	protected final StringBuilder cdataStringBldr;
	protected final XMLImportHelper helper;
	
	protected TimeStamp exportedAt;
	protected List<Record> records;
	protected int recordTagCount;
	
	protected Record currentRecord;
	protected boolean v1xExport;
	
	protected ColumnPointer<?> currentCP;

	public XMLRecordsImporter(StorageClient client)
	{
		super();
		this.client = client;
		this.modelCache = new HashMap<Long, Model>();
		this.tagColumnDepths = new Stack<Integer>();
		this.ignoreTags = new Stack<String>();
		this.cdataStringBldr = new StringBuilder();
		this.helper = new XMLImportHelper();
	}

	/* (non-Javadoc)
	 * @see uk.ac.ucl.excites.sapelli.storage.eximport.xml.Importer#importFrom(java.io.File)
	 */
	@Override
	public List<Record> importFrom(File xmlFile) throws UnknownModelException, IndexOutOfBoundsException, Exception
	{
		// Allocate a new records list:
		records = new ArrayList<Record>(); // (don't reuse old one as this object is returned) 

		// (Re)initialise data structures:
		exportedAt = null;
		recordTagCount = 0;
		ignoreTags.clear();
		tagColumnDepths.clear();
		cdataStringBldr.setLength(0);
		currentRecord = null;
		currentCP = null;
		
		// Parse the file:
		parse(open(xmlFile));
		
		// Return parsed records:
		return records;
	}

	@Override
	public void startDocument() throws SAXException
	{
		// does nothing (for now)
	}

	@SuppressWarnings("unchecked")
	@Override
	public void parseStartElement(String uri, String localName, String qName, XMLAttributes attributes) throws Exception
	{
		// <RecordsExport>
		if(qName.equals(XMLRecordsExporter.TAG_RECORDS_EXPORT) && ignoreTags.isEmpty())
		{
			String exportedAtStr = attributes.getString(SimpleExporter.ATTRIBUTE_EXPORTED_AT, null, true, false);
			if(exportedAtStr != null)
				try
				{
					exportedAt = new TimeStamp(Exporter.ExportedAtFormatter.withOffsetParsed().parseDateTime(exportedAtStr));
				}
				catch(Exception e)
				{
					addWarning("Error upon parsing exportedAt time: " + exportedAtStr);
				}
		}
		// <Record>
		else if(qName.equals(Record.TAG_RECORD) && ignoreTags.isEmpty())
		{
			recordTagCount++;
			Schema schema = null;
			try
			{
				if(currentRecord != null)
					throw new SAXException("Records cannot be nested!");
				
				// This is a new (non-nester) <Record> tag:
				currentCP = null; // (don't move down!)
				
				// Determine format & schema:
				if(attributes.contains(Schema.V1X_ATTRIBUTE_SCHEMA_ID))
				{	// This records was exported by Sapelli v1.x
					v1xExport = true;
					//	Get schema:
					int schemaID = attributes.getRequiredInteger(Record.TAG_RECORD, Schema.V1X_ATTRIBUTE_SCHEMA_ID, "because this is a v1.x record");
					int schemaVersion = attributes.getInteger(Schema.V1X_ATTRIBUTE_SCHEMA_VERSION, Schema.V1X_DEFAULT_SCHEMA_VERSION);
					schema = client.getSchemaV1(schemaID, schemaVersion);
					// we don't use a cache here because all calls to getSchemaV1() are effectively handled by ProjectRecordStore, which has its own caching mechanism  
				}
				else
				{	// This records was exported by Sapelli v2.x 
					v1xExport = false;
					//	Get schema:
					long modelID = attributes.getRequiredLong(Record.TAG_RECORD, Schema.ATTRIBUTE_MODEL_ID);
					int modelSchemaNo = attributes.getRequiredInteger(Record.TAG_RECORD, Schema.ATTRIBUTE_MODEL_SCHEMA_NUMBER);
					// 	Try to find model in cache first:
					if(modelCache.containsKey(modelID))
					{	// Found it...
						schema = modelCache.get(modelID).getSchema(modelSchemaNo);
					}
					else
					{	// Not found, query via client:
						String schemaName = attributes.getString(Schema.ATTRIBUTE_SCHEMA_NAME, null, false, false);
						schema = client.getSchema(modelID, modelSchemaNo, schemaName);
						// Cache the model:
						modelCache.put(modelID, schema.model);
					}
				}
				
				// This is valid <Record> tag, try to get a new, initialised record instance:
				currentRecord = schema != null ? helper.initialise(schema.createRecord()) : null;
			}
			catch(Exception e)
			{
				addWarning("Occurance " + recordTagCount + " of <" + Record.TAG_RECORD + "> is not a valid Sapelli XML record export: " + ExceptionHelpers.getMessageAndCause(e));
				ignoreTags.push(qName);
			}
		}
		// Columns:
		else if(currentRecord != null && ignoreTags.isEmpty())
		{
			// Wipe currentStringBldr:
			cdataStringBldr.setLength(0);
			// Find the column:
			try
			{
				if(currentCP != null)
					currentCP = ColumnPointer.ExtendByName((ColumnPointer<ValueSetColumn<?, ?>>) currentCP, qName, false, false);
				else
					currentCP = ColumnPointer.ByName(currentRecord.getSchema(), qName, false, false);
				// Note: the ColumnPointer#By() and ColumnPointer#ExtendByName() methods support splitting at ValueSetColumn.QUALIFIED_NAME_SEPARATOR
			}
			catch(IllegalArgumentException iae)
			{
				ColumnSet currentCS = (currentCP != null) ? ((ColumnPointer<ValueSetColumn<?, ?>>) currentCP).getColumn().getColumnSet() : currentRecord.getSchema();
				addWarning("Skipping column " + qName + " because it does not exist in " + currentCS.toString());
				ignoreTags.push(qName);
				return;
			}
			
			// Get current column:
			Column<?> currentCol = currentCP.getColumn();
			
			// Skip virtual columns:
			if(currentCol instanceof VirtualColumn)
			{	// We always ignore virtual column values as they never store their own value
				currentCP = currentCP.getParentPointer(); // backtrack to parent
				ignoreTags.push(qName);
				return;
			}
			
			// Manipulate the tagColumnDepths stack (see class javadoc):
			int previousDepth = tagColumnDepths.isEmpty() ? 0 : tagColumnDepths.peek();
			if(previousDepth > 0)
				// we reached the inner level of nested subcolumns, make preceding depth value negative so we know it was nested upon closing:
				CollectionUtils.poke(tagColumnDepths, previousDepth * -1);
			// Push new depth value...
			int newDepth = currentCP.getPathDepth() - Math.abs(previousDepth);
			// ... made negative if the current column is an empty (i.e. non-null but with all-null subcolumns) ValueSetColumn:
			tagColumnDepths.push(newDepth * (currentCol instanceof ValueSetColumn && attributes.getBoolean(XMLRecordsExporter.ATTRIBUTE_VALUESETCOLUMN_EMPTY, Boolean.FALSE) ? -1 : 1));
			
			// Create (sub)ValueSet/Record (if needed):
			currentCP.createValueSet(currentRecord, helper);
		}
		// <?>
		else
		{
			addWarning("Ignored unrecognised or invalidly placed element \"" + qName + "\", ignored.");
			ignoreTags.push(qName);
		}
	}

	@Override
	public void characters(char[] ch, int start, int length) throws SAXException
	{
		cdataStringBldr.append(new String(ch, start, length));
		/* Note:
		 * 	We postpone the parsing of column value Strings until the tag that contains it is closed.
		 * 	This allows us to ignore the *leading* whitespace between nesting levels. See class javadoc.*/
	}
	
	@Override
	public void endElement(String uri, String localName, String qName) throws SAXException
	{
		// <RecordsExport>
		if(qName.equals(XMLRecordsExporter.TAG_RECORDS_EXPORT) && ignoreTags.isEmpty())
		{
			// does nothing (but keep this if-block!!!)
		}
		// </Record>
		else if(qName.equals(Record.TAG_RECORD) && currentRecord != null && ignoreTags.isEmpty())
		{
			// Set missing required values to default (recursively):
			currentRecord.resetEmptyColumns(true, true);
			
			// Recursive "filledness" check:
			if(!currentRecord.isFilled(true)) // recursive "filledness" check
				addWarning("Imported record (#" + recordTagCount + ") is incomplete: " + currentRecord.toString(false));
			
			// Add parsed record:
			records.add(currentRecord);
			
			// And forget about it:
			currentRecord = null;
		}
		// Columns:
		else if(currentCP != null && currentRecord != null && ignoreTags.isEmpty()) // currentCP not being null also implies there is a currentRecord and tagColumnDepths is not empty
		{
			// Get valueString:
			String valueString =
				tagColumnDepths.peek() > 0 ?
					cdataStringBldr.toString() :	// CDATA contents of the tag being closed (possibly empty, never null)
					""; 							// force passing of empty String (see note below)
			/* Note:
			 *	When the column depth is negative this means we are either handling the outer tag of
			 *	a ValueSetColumn in nested mode, possibly marked as empty. Or the collapsed and empty-marked
			 *	tag for a ValueSetColumn in flat mode. In both case we replace the CDATA contents with ""
			 *	which will cause the XMLImportColumnValueParser to store a new (empty) sub-ValueSet in the column.*/
					
			// Parse & store value:
			try
			{
				// Get the pointed-at column:
				Column<?> column = currentCP.getColumn();
				
				// Never parse values of virtual columns (should never happen as this is checked for in parseStartElement(), but just in case...):
				if(!(column instanceof VirtualColumn))
				{
					// Get (sub)ValueSet/Record:
					ValueSet<?> valueSet = currentCP.getValueSet(currentRecord, false /*don't create*/); // (sub)record recreation happens in parseStartElement (and should stay there!)
					
					if(v1xExport && column instanceof LocationColumn)
						// Backwards compatibility with old location formats:
						((LocationColumn) column).storeValue(valueSet, Location.parseV1X(valueString));
					else if(v1xExport && column instanceof OrientationColumn)
						// Backwards compatibility with old orientation format:
						((OrientationColumn) column).storeValue(valueSet, Orientation.parseV1X(valueString));
					else
						// Use helper to parse & store value:
						helper.parseAndStoreValue(column, valueString, valueSet);
				}
			}
			catch(Exception e)
			{
				addWarning("Error upon parsing value (" + cdataStringBldr.toString() + ") for column " + currentCP.getQualifiedColumnName() + " on record #" + recordTagCount + ": " + ExceptionHelpers.getMessageAndCause(e));
			}
			
			// Backtrack currentCP (as many levels as represented by the tag being closed):
			for(int l = Math.abs(tagColumnDepths.pop()); l > 0; l--)
				if(currentCP != null) // (just in case)
					currentCP = currentCP.getParentPointer();
		}
		// <?>
		else if(!ignoreTags.isEmpty())
		{
			ignoreTags.pop();
		}
	}

	@Override
	public void endDocument() throws SAXException
	{
		// does nothing (for now)
	}
	
	/* (non-Javadoc)
	 * @see uk.ac.ucl.excites.sapelli.storage.eximport.Importer#getLastImportExportedAtTime()
	 */
	@Override
	public TimeStamp getLastImportExportedAtTime()
	{
		return exportedAt;
	}
	
	/**
	 * Helper class which turns String representations into column values.
	 * 
	 * @see {@link XMLRecordsExporter#XMLColumnValueStringProvider}
	 * @see {@link ImportHelper}
	 * 
	 * @author mstevens
	 */
	private class XMLImportHelper extends ImportHelper
	{

		/* (non-Javadoc)
		 * @see uk.ac.ucl.excites.sapelli.storage.eximport.helpers.ImportColumnValueParser#getSubValueSet(uk.ac.ucl.excites.sapelli.storage.model.ValueSetColumn, java.lang.String)
		 */
		@Override
		protected <VS extends ValueSet<CS>, CS extends ColumnSet> VS getSubValueSet(ValueSetColumn<VS, CS> valueSetCol, String valueString) throws Exception
		{
			if(valueString.isEmpty())
				return valueSetCol.getNewValueSet();
			else
				return super.getSubValueSet(valueSetCol, valueString);
		}

	}

}
